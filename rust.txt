Rust
For Documentation: rustup doc
For "The Book": rustup doc --book
or online: https://doc.rust-lang.org/book

`rustup` is Rust's Toolchain tool. Get with https://www.rust-lang.org/learn/get-started
`rustc` is Rust's compiler (you generally use cargo, which calls the compiler). Install rustc using rustup.
`cargo` is Rust's package manager
    - cargo: build run test doc publish --version
    - cargo new <proj>

More References:
- Cheatsheet: https://cheats.rs/
- another cheatsheet: https://github.com/donbright/rust-lang-cheat-sheet
- Are we web yet? https://www.arewewebyet.org/
- Are we async yet? https://areweasyncyet.rs/
    - https://tokio.rs/

2022-05 my open questions:
- &str vs String
- traits vs attributes
- how to structure package
- how to give good expect msg

# Ch 1: Getting started

Update: rustup update

Version: rustc --version
rustc 1.60.0 (7737e0b5c 2022-04-04)
rustc 1.61.0 (fe5b13d68 2022-05-18)


println!
! = macro

Create new project:
cargo new hello_cargo

Build and run:
cargo build
./target/debug/hello_cargo

Build and run (one step):
cargo run

Fast check if code *would* compile:
cargo check

Release:
cargo build --release


let x = "foo"
let mut guess = String::new();

use std::io;

io::stdin()
    .read_line(&mut guess)
    .expect("Failed!"); // expect crashes on Err

The number 0.8.3 is actually shorthand for ^0.8.3, which means any version that is at least 0.8.3 but below 0.9.0

Rust packages are "crates" and are found @ https://crates.io/

cargo build is smart, only pulls or compiles as necessary.

Cargo.lock contains the locked versions (like locks in other pkg mgrs).
For binaries/applications: commit cargo.lock
For libraries: do NOT commit cargo.lock 

Update Cargo.lock:
cargo update

Generates and opens documentation:
cargo doc --open

# Ch 3: Common programming

Can shadow variable names with let

        match guess.cmp(&secret) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

const for constants

Integers: u8 i32 etc... and isize and usize for collections
Floats f32 f64
bool true false
tupels, the unit value () is default return value
Array: let a: [i32, 5] = [1,2,3,4,5]

fn five() -> i32 {
    5
}

fn plus_one(x: i32) -> i32 {
    x + 1           // notice this is a default return expression, no semicolon
}


fn plus_one(x: i32) -> i32 {
    x + 1; // WONT COMPILE b/c this is a statement, because it has a semicolon
}

if number < 5 {
    println!("condition was true");
} else {
    println!("condition was false");
}

loop {
    // infinite loop
}

while COND {

}

for ELEM in COLL {

}

# Ch 4: Ownership

The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. 

let s = ...
do_something(s); // ownership is passed to function
// s is invalid here

&foo // reference to foo, like a pointer. Typically passed to a method

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

&mut foo // a mutable reference to foo, passed to methods that will mutate foo

Only one &mut ref at a time!

A reference’s scope starts from where it is introduced and continues through the last time that reference is used.

The ability of the compiler to tell that a reference is no longer being used at a point before the end of the scope is called Non-Lexical Lifetimes (NLL for short).

Let’s recap what we’ve discussed about references:
1. At any given time, you can have either one mutable reference or any number of immutable references.
2. References must always be valid.

Copy trait is on types that are copied.

Copy extends Clone.

Copy is implicit and inexpensive (fast) bit-wise copy. Rust does not allow you to reimplement Copy.
https://doc.rust-lang.org/std/marker/trait.Copy.html

Clone is explicit and may or may not be expensive.
Clone is more general.
https://doc.rust-lang.org/std/clone/trait.Clone.html

A slice is a kind of reference, so it does not have ownership.

String literals are slices:

let s = "Hello, world!";
The type of s here is &str: it’s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &str is an immutable reference.

# Ch 5: Structs

struct User {
    active: bool;
    username: String;
    email: String;
    sign_in_count: u64;
}

let user = User {
    active: true,
    username: String::from("valbaca"),
    email: String::from("valbaca@gmail.com"),
    sign_in_count: 100
};

let mut another_user = ...;
another_user.email = String::from("valbaca@hotmail.com");

Can shorthand if variables match field names:

let user = User {
    active,
    username,
    email,
    sign_in_count
}

Struct update:

let user2 = User {
    email: String::from("valbaca@gmail.com"),
    ..user1
}

Tuple struct:
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}

Unit-like struct:
struct AlwaysEqual;

First trait:
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}

# Ch 6

"if let" is sugar for the simple case where you only want one clause from a "match" and avoid using _
fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
}

fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
}

can even do "if let else"

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }
}

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}

# Ch 7: Packages, Crates, & Modules:

A crate is a library or binary.
A package is one or more crates. A package contains a Cargo.toml

Cargo convention is crate binary root is src/main.rs and library root is src/lib.rs
A package can have multiple binary crates by placing files in src/bin

Create new library: cargo new --lib restaurant

Modules organize and handle privacy of code

mod <name> {
}

src/main.rs and src/lib.rs are crate roots, either of those files form a modlule named `crate` at the root of the crate's module structure, the module tree.

Module tree paths can take two forms:
1. An absolute path starts from a crate root by using a crate name or a literal crate.
2. A relative path starts from the current module and uses self, super, or an identifier in the current module.

"crate" is like "/" in path dirs
"super" is like ".."

items (functions, methos, structs, enums, modules, & constants) are private by default. children have access to parent's items b/c children often hide implementations.

use `pub` to make public

`use` is like Java's import.
It's idiomatic to only `use` up to the module, don't include the full function so you know where the function came from:

use self::front_of_house::hosting;          // idiomatic
pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();             // obvious where fn comes from
}

Nested paths:
use std::cmp::Ordering;
use std::io;
VS
use std::{cmp::Ordering, io};


Separating code into files:


// file: src/lib.rs
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}

// file: src/front_of_house.rs
pub mod hosting {
    pub fn add_to_waitlist() {}
}

Using a semicolon after mod front_of_house rather than using a block tells Rust to load the contents of the module from another file with the same name as the module.

# Ch 8: Collections

- A vector `Vec` allows you to store a variable number of values next to each other.
- A string is a collection of characters. We’ve mentioned the String type previously, but in this chapter we’ll talk about it in depth.
- A hash map allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a map.

More collections: https://doc.rust-lang.org/std/collections/index.html
Vec VecDeque LinkedList HashMap BTreeMap HashSet BinaryHeap

## Vec
let v: Vec<i32> = Vec::new();

vec! macro:
let v = vec![1, 2, 3];

push(e): to push element e

When vectors drop out of scope, its contents do too.

get(i): to get at index i, returns Option 
or use &v[i] for direct access (can crash though)

Read-only iteration:
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{}", i);
    }

Mutable iteration:
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }

To hold different types of values, use enums:
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];

Vec methods: len push pop extend ::from

vec![0; 5] // elem * times

## Slices: &[usize]

let v: &[_] = &v;

(Underneath, a vec is basically a ptr, len, and cap)

## Strings

str: string slice, in core language, usually as &str
String: type in std lib, growable, mutable, owned UTF-8 

"asdf" // string literal
String::from("asdf")    // String
"asdf".to_string()      // String

push_str to concat
or s1 + &s2

format!("{}-{}-{}", s1, s2, s3);

Rust strings do NOT support access by index, s[0] doesn't compile

Strings are UTF8, which you can look at as bytes, scalar values, and grapheme clusters ("letters"?)

“नमस्ते” could be looked at as either:
1. u8: [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
2. char: ['न', 'म', 'स', '्', 'त', 'े']
3. grapheme clusters: ["न", "म", "स्", "ते"]

Default for-in goes over the chars. for-in over the .bytes() for bytes

## Hash Maps

    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

Methods: insert 

Can use keys.into_iter().zip(vals_iter).collect() to turn a paired vec of keys and a vec of vals into a hashmap. Notice that .collect() can return multiple collections, so the Hash Map type must be specified, but the key-val types can be left to be inferred:

    use std::collections::HashMap;

    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];

    let mut scores: HashMap<_, _> =
        teams.into_iter().zip(initial_scores.into_iter()).collect();

Adding to a hash map moves (or copies if they have Copy trait).

for (key, value) in &map {}

Insert only if absent:
        scores.entry(String::from("Yellow")).or_insert(50);

Updating value based on previous value:
    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

SipHash is the default hashing algo

# Ch 9: Error Handling

Recoverable and non-recoverable errors.

Uses Result<T, E> for recoverable errors and panic! for unrecoverable.

panic! triggers stack unrolling, but this can be turned into a hard abort via Cargo.toml

the key to reading the backtrace is to start from the top and read until you see files you wrote.

Recoverable errors use Result
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }

Can use `match` for type matching:
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}


That's a lot of match...we can use closures instead:

use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}

Or just unwrap() or expect(msg)
expect makes it a bit easier to find the cause

OR use the ? operator, which basically eliminates boilerplate around error propogation.
But it only works if the error type is compatible with the fn return type, i.e. Result or Option
`main` returns (), so cannot use ? within main.
However, you can change the return type of main to be Result<(), E> and put Ok(()) at the end

TIP: if you're just actually trying to read from a file, use: fs::read_to_string("hello.txt")


https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html

Ch 10: Generic Types, Traits, and Lifetimes

fn largest<T>(list: &[T]) -> T {...}

struct Point<T> {
    x: T,
    y: T,
}

enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

// for generic methods

impl <T> Point<T> {...} // have to specify twice

// can also specify methods only for particular types

impl Point<f32> { 
    fn dist_from_origin(&self) -> f32 {...}
}

Rust keeps the runtime low via monomorphization. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.  The generic Option<T> is replaced with the specific definitions created by the compiler. 

Traits: A trait defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.

Traits are similar but different to interfaces/protocols.

pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {...}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        ...
    }
}

Can’t implement external traits on external types.
Can provide default implementations of trait methods.

Using traits as parameters in other functions:
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

Repeating `impl Summary` is tedious, so you can use Trait Bound, which is more succinct if the trait type is repeated:
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}

Type unions with `+`
pub fn notify(item: &(impl Summary + Display)) {
pub fn notify<T: Summary + Display>(item: &T) {

If it's still too cluttered, can use `where`:
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {...}
versus
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{...}

Using `impl Trait` on return types only works if it returns one type (?!)
(Looks like this can be worked around with Box<T> at the expense runtime speed)

So `longest` would actually look more like (but not exactly)
fn largest<T: PartialOrd>(list: &[T]) -> T {...}

But when we made the largest function generic, it became possible for the list parameter to have types in it that don’t implement the Copy trait.

So we have to also add Copy:
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {...}

fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

OR

fn largest<T: PartialOrd + Copy>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = &item;
        }
    }
    largest
}

In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn’t define the method. But Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run.

Lifetimes

Every reference in Rust has a lifetime, which is the scope for which that reference is valid.
The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it’s intended to reference. 

Similar to generics...functions can accept references with any lifetime by specifying a generic lifetime parameter....the names of lifetime parameters must start with an apostrophe (') and are usually all lowercase and very short, like generic types. Most people use the name 'a for the first lifetime annotation. We place lifetime parameter annotations after the & of a reference, using a space to separate the annotation from the reference’s type.

&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does not refer to one of the parameters, it must refer to a value created within this function. However, this would be a dangling reference because the value will go out of scope at the end of the function. 

For structs that hold a reference:
struct ImportantExcerpt<'a> {
    part: &'a str,
}

Early on, there were some heuristics (lifetime elision rules) put into the compiler to handle the very straightforward cases:
fn first_word(s: &str) -> &str {...}
fn first_word<'a>(s: &'a str) -> &'a str {...}

The compiler uses three rules to figure out the lifetimes of the references when there aren’t explicit annotations.
1. The compiler assigns a lifetime parameter to each parameter that’s a reference.
2. If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters
3. If there are multiple input lifetime parameters, but one of them is &self or &mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters.

struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}

Static lifetime:

One special lifetime we need to discuss is 'static, which denotes that the affected reference can live for the entire duration of the program. All string literals have the 'static lifetime, which we can annotate as follows:

Now, altogether!

use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    println!("The longest string is {}", result);
}


Likely need to review this often:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

11. Writing Automated Tests

Attributes (are like Annotations)
#[test]
fn some_test() {
    assert!(...);
    assert!(..., "Expected blah but got {}", actual);
    assert_eq!(...);
    assert_ne!(...);
}

#[test]
#[should_panic]
fn ensure_panics() {...}


Consider adding the traits to make comparisons and printing better:
#[derive(PartialEq, Debug)]


Can also use Result<T, E> in Tests:
#[test]
fn it_works() -> Result<(), String> {
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err(String::from("math didn't work"))
    }
}

By default, printing for passing tests is filtered (captured). To see it:
$ cargo test -- --show-output

To run certain test, just give the test name:
cargot test explore # only runs tests that start with explore

(Just like JUnit)
Ignore with #[ignore]
Run *only* ignored: cargo test -- --ignored
Run *all*, including ignored: cargo test -- --include-ignored

#[cfg(test)] is what specifies that the tests run when you do `cargo test`

You can test private functions:
use super::*;

Prefer to have a small src/main.rs file which calls src/lib.rs. You then don't need to test the main.rs and can just unit-test the lib.rs

Ch 12. I/O Project

.clone() has a runtime cost. Generally use more optimized methods but Don't Prematurely Optimize

panic! is more for programming problems, not as good for invalid input.

Important `use`:
- std::env fs process
- std::error::Error

Box<dyn Error> means "the function will return a types that implements the Error trait, but we don't have to specify what the particular return type will be

`dyn` == dynamic

Ok(()) is Ok returning the unit (), it's basically `void`; it's for code run for side-effects only. Just like Unit in Kotlin!

Two ways of error handling:

let result = do_thing(...).unwrap_or_else (|err| {...});
^ this continues with the result

if let Err(e) = run(...) { ... }
^ this throws away the result