This file has notes for more intermediate or niche Go notes EXCEPT those related to CSP (see go-csp.txt)
These are parts of the language not always needed or are beyond "introduction" scope.

# Generics

func Index[T comparable](s []T, x T) int

type List[T any] struct {
	next *List[T]
	val  T
}

# Testing, import "testing"

$ go test
$ go test -v        # verbose
$ go test -cover    # coverage analysis
go test -v -bench . # benchmarks (see below)

Write a function with name staring with "Test"

func TestFoo(t *testing.T) {
    t.Errorf("log an error %s", s)
}

Using "table-driven" allows writing parameterized tests easily

func TestTableDriven(t *testing.T) {
    var tests = []struct {
        a, b int        // input
        exp int        // expected
    }{
        {0, 1, 0},
        {1, 0, 0},
        // etc.
    }
    for _, tt := range tests {
        testname := fmt.Sprintf("%d,%d", tt.a, tt.b)
        t.Run(testname, func(t *testing.T) {
            act := SUT(tt.a, tt.b)
            if act != tt.exp {
                t.Errorf("actual %d, expected %d", act, tt.exp)
            }
        })
    }
}


## Benchmark

$ go test -bench=.
$ go test -v -bench . -benchtime 50s

Benchmark tests typically go in _test.go files and are named beginning with Benchmark. The testing runner executes each benchmark function several times, increasing b.N on each run until it collects a precise measurement.

foo_test.go

func BenchmarkIntMin(b *testing.B) {
    for i := 0; i < b.N; i++ {
        IntMin(1, 2)
    }
}


https://go.dev/doc/tutorial/add-a-test


## Testable Examples

https://go.dev/blog/examples

In _test.go file, Example()

func ExampleFoo()     // documents the Foo function or type
func ExampleBar_Qux() // documents the Qux method of type Bar
func Example()        // documents the package as a whole

func init()  // run before anything else is run, after vars init'd

# Sorting

sort.Strings .Ints .IntsAreSorted

## Custom Sorting: Len/Swap/Less

type byLength []string

func (s byLength) Len() int {
    return len(s)
}
func (s byLength) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}
// Less is the most important for sort.Sort
func (s byLength) Less(i, j int) bool {
    return len(s[i]) < len(s[j])
}

func main() {
    fruits := []string{"peach", "banana", "kiwi"}
    sort.Sort(byLength(fruits))
    fmt.Println(fruits)
}


Build tags:
// +build prod, dev, test

