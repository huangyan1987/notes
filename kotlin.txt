To Read:
Collections https://kotlinlang.org/docs/collections-overview.html#collection
Coroutines https://kotlinlang.org/docs/coroutines-guide.html
Blog https://blog.jetbrains.com/kotlin/2020/11/server-side-development-with-kotlin-frameworks-and-libraries/
kotlin.test https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/

https://kotlinlang.org/

Why Kotlin?
"Modern, concise and safe programming language"
A more "effective" Java with most of "Effective Java" built-in
- Fully interopable with Java
- First-class support from IntelliJ (JetBrains), Android (Google), and Spring
- Shallow learning curve
- Better null-type handling: String? vs String! thing?.field and thing ?: "default"
- Coroutines
- String template: "Buy now for $cost"
- ranges: x in 1..10
- Inline classes: stop using String for customerId/marketplaceId/charityId/everything!
- Type aliases: more expressive code. Cache vs Map<String, Object>
- For unit tests: fun `descriptive test name`()
- Immutable collections that are actually nice to work with
- String template and concat (+) automatically use StringBuilder for performance
- Simple primitive conversion, .toInt(). Forget boxing/unboxing rules.
- Simply prefer val over var. No need for "final" everywhere, it's the default for parameters and classes!
- Simple lazy-initializers with lateinit
- Extensions replace "Util" classes
- `==` does what it ought to again (.equals in Java). While `===` is used for same reference (hardly ever needed!)
- One True Language: primarily for JVM but also compiles to JavaScript and native

And Java agrees!
- SOLID Open-closed principle: Kotlin classes are sealed by default
    - sealed classes added in Java 15..17 (but not the default)
- properties & data classes (no more getters/setters or Lombok)
    - "records" added in Java 14..16
- when expression
    - similar to pattern matching switch previewed in Java 17

Why not...
- Scala? Decrease in readability, implicits, rough compatiability, less support, learning curve
- Clojure? Major paradigm shift, steep learning curve, poor IDE support, runtime = slow

fun main(args: Array<String>): Unit {

}

or just
fun main() {

}

when(foo) {
    1 -> "One"
    "Hello" -> "World"
    else -> "default"
}

`in` is an operator for ranges and collections
x in xs
y in 0..100         // ranges INclude last

use `!in` for not-checks
if (person !in friends) ignoreCall()

`is` is used for type checks
if (s is String) {
    return s.length
}

`with` effectively reassigns the `this` to what's given:
with (book) {
    println("$title by $author")
}
vs.
println("${book.title} by ${book.author}")

A method in Java but a property (?) in Kotlin:
Strings use s.length        
Collections use c.size
Arrays (still) use arr.size

Strings:
s.ifBlank { "Default" }

Collections have .joinToString
joinToString is very flexible

Lists:
listOf(...)
use .lastIndex

getOrElse to do defaults:
val hundo = al.getOrElse(100) { "default" } 
val hundo = al.getOrElse(100) { i ->  "default for $i"}

Map:
val map = mapOf("a" to 1, "b" to 2, "c" to 3)

for ((k, v) in map) {
}

speaking of for-loops:
for (i in 1..10)        // [1,10] inclusive of end
for (i in 1 until 10)   // [1,10) exclusive of end
for (i in 0..100 step 2) // every other
for (i in 100 downTo 1)  // reverse
(1..10).forEach {...}

val s: String by lazy {
    // lazy init
}

data class Book(val title: String, val author: String)

Extensions:
fun String.spaceToCamelCase() {...}

Singleton:
object YourName {
}

Abstract & Overrides:
abstract class ...
    abstract fun ...
override fun ...

Idioms https://kotlinlang.org/docs/idioms.html

if-not null:
value?.let { ... }

map if-not null:
val mapped = value?.let { tx(it) } ?: "default"

try-catch expression:
val result = try {
    calc()
} catch (e: ArithmeticException) {
    throw IllegalStateException(e)
}

Single-expression functions:
fun answer() = 42
^ good v bleh
fun answer(): Int {
    return 42
}

Configure with apply:
val rect = Rectangle().apply {
    length = 4
    breadth = 5
    color = 0xFF00FF
}

try-with resources:
reader().use {reader -> ... }

Generic functions:
//  public final class Gson {
//     ...
//     public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
//     ...

inline fun <reified T: Any> Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)

Use TODO() to mark code as unimplemented


KDoc is the format for documentation. Dokka is the tool.
https://kotlinlang.org/docs/kotlin-doc.html
Note: use the @Deprecated annotation, not documentation